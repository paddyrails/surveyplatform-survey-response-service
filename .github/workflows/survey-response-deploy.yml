name: 'Survey Response: Deploy'

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment'
        required: true
        default: 'dev'
        type: choice
        options: [dev, staging, prod]
      tag:
        description: 'Image tag (leave empty for latest)'
        required: false

env:
  SERVICE_NAME: survey-response-service
  RESOURCE_GROUP: rg-surveyplatform-${{ github.event.inputs.environment }}
  NAMESPACE: survey-platform

jobs:
  deploy:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      - uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get Resources
        id: res
        run: |
          echo "aks=$(az aks list -g ${{ env.RESOURCE_GROUP }} --query '[0].name' -o tsv)" >> $GITHUB_OUTPUT
          ACR_NAME=$(az acr list -g ${{ env.RESOURCE_GROUP }} --query '[0].name' -o tsv)
          echo "acr_server=$(az acr show -n $ACR_NAME --query loginServer -o tsv)" >> $GITHUB_OUTPUT
          echo "kv=$(az keyvault list -g ${{ env.RESOURCE_GROUP }} --query '[0].name' -o tsv)" >> $GITHUB_OUTPUT

      - name: Get AKS Credentials
        run: az aks get-credentials -g ${{ env.RESOURCE_GROUP }} -n ${{ steps.res.outputs.aks }} --overwrite-existing

      - uses: azure/setup-kubectl@v4

      - name: Create Namespace & Secrets
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          KV="${{ steps.res.outputs.kv }}"
          DB=$(az keyvault secret show --vault-name $KV --name survey-response-db-connection --query value -o tsv 2>/dev/null || echo "")
          SB=$(az keyvault secret show --vault-name $KV --name servicebus-connection-string --query value -o tsv 2>/dev/null || echo "")
          REDIS=$(az keyvault secret show --vault-name $KV --name redis-connection-string --query value -o tsv 2>/dev/null || echo "")
          
          kubectl create secret generic ${{ env.SERVICE_NAME }}-secrets --namespace ${{ env.NAMESPACE }} \
            --from-literal=db-connection="$DB" \
            --from-literal=servicebus-connection="$SB" \
            --from-literal=redis-connection="$REDIS" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy
        run: |
          TAG="${{ github.event.inputs.tag || 'latest' }}"
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.SERVICE_NAME }}
            namespace: ${{ env.NAMESPACE }}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: ${{ env.SERVICE_NAME }}
            template:
              metadata:
                labels:
                  app: ${{ env.SERVICE_NAME }}
              spec:
                containers:
                  - name: ${{ env.SERVICE_NAME }}
                    image: ${{ steps.res.outputs.acr_server }}/${{ env.SERVICE_NAME }}:$TAG
                    ports:
                      - containerPort: 8080
                    env:
                      - name: ASPNETCORE_ENVIRONMENT
                        value: "Production"
                      - name: ASPNETCORE_URLS
                        value: "http://+:8080"
                      - name: ConnectionStrings__DefaultConnection
                        valueFrom:
                          secretKeyRef:
                            name: ${{ env.SERVICE_NAME }}-secrets
                            key: db-connection
                      - name: ServiceBus__ConnectionString
                        valueFrom:
                          secretKeyRef:
                            name: ${{ env.SERVICE_NAME }}-secrets
                            key: servicebus-connection
                      - name: Redis__ConnectionString
                        valueFrom:
                          secretKeyRef:
                            name: ${{ env.SERVICE_NAME }}-secrets
                            key: redis-connection
                    resources:
                      requests:
                        memory: "128Mi"
                        cpu: "100m"
                      limits:
                        memory: "256Mi"
                        cpu: "500m"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.SERVICE_NAME }}
            namespace: ${{ env.NAMESPACE }}
          spec:
            selector:
              app: ${{ env.SERVICE_NAME }}
            ports:
              - port: 80
                targetPort: 8080
          ---
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${{ env.SERVICE_NAME }}-ingress
            namespace: ${{ env.NAMESPACE }}
            annotations:
              nginx.ingress.kubernetes.io/rewrite-target: /\$2
              nginx.ingress.kubernetes.io/use-regex: "true"
          spec:
            ingressClassName: nginx
            rules:
              - http:
                  paths: # disabled for separate repo
                    - path: /api/responses(/|$)(.*)
                      pathType: ImplementationSpecific
                      backend:
                        service:
                          name: ${{ env.SERVICE_NAME }}
                          port:
                            number: 80
          EOF

      - name: Wait & Summary
        run: |
          kubectl rollout status deployment/${{ env.SERVICE_NAME }} -n ${{ env.NAMESPACE }} --timeout=300s
          IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          echo "## âœ… Deployed" >> $GITHUB_STEP_SUMMARY
          echo "**Endpoint:** http://$IP/api/responses" >> $GITHUB_STEP_SUMMARY
